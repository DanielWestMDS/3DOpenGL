#version 460 core

#define WORK_GROUP_SIZE_X 128

layout (local_size_x = WORK_GROUP_SIZE_X,
        local_size_y = 1,
        local_size_z = 1
        ) in;

layout(std430, binding = 0) buffer PositionLifeBuffer { vec4 PositionLife[]; };
layout(std430, binding = 1) buffer VelocityBuffer { vec4 Velocity[]; };

uniform int SeedLife;
uniform int SeedX;
uniform int SeedY;
uniform int SeedZ;
uniform vec4 VelocityLifeChange;
uniform vec3 EmitterOrigin;
uniform bool bExplode;

void ResetParticle(uint Index);
double RandomValue(uint ID, int Seed);

double RandomValue(uint ID, int Seed)
{
    double RandomValue;
    int Noise = int(ID) * Seed;
    Noise = (Noise << 13) ^ Noise;

    int T = (Noise * (Noise * Noise * 15731 + 789221) + 1376312589) & 0x7fffffff;
    RandomValue = 1.0 - double(T) * 0.93132257461548515625e-9;
    return RandomValue;
}

void ResetParticle(uint Index)
{
    float LifeModifier = 5.0f;
    float SpeedFactor = 20.0f; 

    // Initial Position and Lifespan
    PositionLife[Index] = vec4(EmitterOrigin.xyz, (RandomValue(Index, SeedLife) + 1) * 0.5f * LifeModifier);

    // Generate random direction for particle velocity
    vec3 randomDirection = normalize(vec3(
        RandomValue(Index, SeedX) * 2.0 - 1.0,
        RandomValue(Index, SeedY) * 2.0 - 1.0,
        RandomValue(Index, SeedZ) * 2.0 - 1.0
    ));
    Velocity[Index] = vec4(randomDirection * SpeedFactor, 0.0f);
}

void main()
{
    uint Index = gl_GlobalInvocationID.x;

    // If the firework should explode, reset particles once
    if (bExplode && PositionLife[Index].w <= 0.0f)
    {
        ResetParticle(Index);
    }

    // Apply gravity and update position only if the particle is alive
    if (PositionLife[Index].w > 0.0f)
    {
        // Apply gravity
        Velocity[Index].xyz += VelocityLifeChange.xyz;

        // Move particle
        PositionLife[Index].xyz += Velocity[Index].xyz * VelocityLifeChange.w;

        // Decrease lifespan
        PositionLife[Index].w -= VelocityLifeChange.w;
    }
}
